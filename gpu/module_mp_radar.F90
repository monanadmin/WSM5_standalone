!+---+-----------------------------------------------------------------+
!..This set of routines facilitates computing radar reflectivity.
!.. This module is more library code whereas the individual microphysics
!.. schemes contains specific details needed for the final computation,
!.. so refer to location within each schemes calling the routine named
!.. rayleigh_soak_wetgraupel.
!.. The bulk of this code originated from Ulrich Blahak (Germany) and
!.. was adapted to WRF by G. Thompson.  This version of code is only
!.. intended for use when Rayleigh scattering principles dominate and
!.. is not intended for wavelengths in which Mie scattering is a
!.. significant portion.  Therefore, it is well-suited to use with
!.. 5 or 10 cm wavelength like USA NEXRAD radars.
!.. This code makes some rather simple assumptions about water
!.. coating on outside of frozen species (snow/graupel).  Fraction of
!.. meltwater is simply the ratio of mixing ratio below melting level
!.. divided by mixing ratio at level just above highest T>0C.  Also,
!.. immediately 90% of the melted water exists on the ice's surface
!.. and 10% is embedded within ice.  No water is "shed" at all in these
!.. assumptions. The code is quite slow because it does the reflectivity
!.. calculations based on 50 individual size bins of the distributions.
!+---+-----------------------------------------------------------------+

module module_mp_radar

   use module_wrf_error

   public :: rayleigh_soak_wetgraupel
   public :: radar_init
   private :: m_complex_water_ray
   private :: m_complex_ice_maetzler
   private :: m_complex_maxwellgarnett
   private :: get_m_mix_nested
   private :: get_m_mix
   private :: WGAMMA
   private :: GAMMLN

   integer, parameter, public:: nrbins = 50
   double precision, dimension(nrbins + 1), public:: xxDx
   double precision, dimension(nrbins), public:: xxDs, xdts, xxDg, xdtg
   double precision, parameter, public:: lamda_radar = 0.10 ! in meters
   double precision, public:: K_w, PI5, lamda4
   complex*16, public:: m_w_0, m_i_0
   double precision, dimension(nrbins + 1), public:: simpson
   double precision, dimension(3), parameter, public:: basis = &
      (/1.d0/3.d0, 4.d0/3.d0, 1.d0/3.d0/)
   real, dimension(4), public:: xcre, xcse, xcge, xcrg, xcsg, xcgg
   real, public:: xam_r, xbm_r, xmu_r, xobmr
   real, public:: xam_s, xbm_s, xmu_s, xoams, xobms, xocms
   real, public:: xam_g, xbm_g, xmu_g, xoamg, xobmg, xocmg
   real, public:: xorg2, xosg2, xogg2

   integer, parameter, public:: slen = 20
   character(len=slen), public:: &
      mixingrulestring_s, matrixstring_s, inclusionstring_s, &
      hoststring_s, hostmatrixstring_s, hostinclusionstring_s, &
      mixingrulestring_g, matrixstring_g, inclusionstring_g, &
      hoststring_g, hostmatrixstring_g, hostinclusionstring_g

!..Single melting snow/graupel particle 90% meltwater on external sfc
   double precision, parameter:: melt_outside_s = 0.9d0
   double precision, parameter:: melt_outside_g = 0.9d0

   character*256:: radar_debug

contains

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

   subroutine radar_init

      implicit none
      integer:: n
      PI5 = 3.14159*3.14159*3.14159*3.14159*3.14159
      lamda4 = lamda_radar*lamda_radar*lamda_radar*lamda_radar
      m_w_0 = m_complex_water_ray(lamda_radar, 0.0d0)
      m_i_0 = m_complex_ice_maetzler(lamda_radar, 0.0d0)
      K_w = (abs((m_w_0*m_w_0 - 1.0)/(m_w_0*m_w_0 + 2.0)))**2

      do n = 1, nrbins + 1
         simpson(n) = 0.0d0
      end do
      do n = 1, nrbins - 1, 2
         simpson(n) = simpson(n) + basis(1)
         simpson(n + 1) = simpson(n + 1) + basis(2)
         simpson(n + 2) = simpson(n + 2) + basis(3)
      end do

      do n = 1, slen
         mixingrulestring_s(n:n) = char(0)
         matrixstring_s(n:n) = char(0)
         inclusionstring_s(n:n) = char(0)
         hoststring_s(n:n) = char(0)
         hostmatrixstring_s(n:n) = char(0)
         hostinclusionstring_s(n:n) = char(0)
         mixingrulestring_g(n:n) = char(0)
         matrixstring_g(n:n) = char(0)
         inclusionstring_g(n:n) = char(0)
         hoststring_g(n:n) = char(0)
         hostmatrixstring_g(n:n) = char(0)
         hostinclusionstring_g(n:n) = char(0)
      end do

      mixingrulestring_s = 'maxwellgarnett'
      hoststring_s = 'air'
      matrixstring_s = 'water'
      inclusionstring_s = 'spheroidal'
      hostmatrixstring_s = 'icewater'
      hostinclusionstring_s = 'spheroidal'

      mixingrulestring_g = 'maxwellgarnett'
      hoststring_g = 'air'
      matrixstring_g = 'water'
      inclusionstring_g = 'spheroidal'
      hostmatrixstring_g = 'icewater'
      hostinclusionstring_g = 'spheroidal'

!..Create bins of snow (from 100 microns up to 2 cm).
      xxDx(1) = 100.d-6
      xxDx(nrbins + 1) = 0.02d0
      do n = 2, nrbins
         xxDx(n) = DEXP(DFLOAT(n - 1)/DFLOAT(nrbins) &
                        *DLOG(xxDx(nrbins + 1)/xxDx(1)) + DLOG(xxDx(1)))
      end do
      do n = 1, nrbins
         xxDs(n) = DSQRT(xxDx(n)*xxDx(n + 1))
         xdts(n) = xxDx(n + 1) - xxDx(n)
      end do

!..Create bins of graupel (from 100 microns up to 5 cm).
      xxDx(1) = 100.d-6
      xxDx(nrbins + 1) = 0.05d0
      do n = 2, nrbins
         xxDx(n) = DEXP(DFLOAT(n - 1)/DFLOAT(nrbins) &
                        *DLOG(xxDx(nrbins + 1)/xxDx(1)) + DLOG(xxDx(1)))
      end do
      do n = 1, nrbins
         xxDg(n) = DSQRT(xxDx(n)*xxDx(n + 1))
         xdtg(n) = xxDx(n + 1) - xxDx(n)
      end do

!..The calling program must set the m(D) relations and gamma shape
!.. parameter mu for rain, snow, and graupel.  Easily add other types
!.. based on the template here.  For majority of schemes with simpler
!.. exponential number distribution, mu=0.

      xcre(1) = 1.+xbm_r
      xcre(2) = 1.+xmu_r
      xcre(3) = 1.+xbm_r + xmu_r
      xcre(4) = 1.+2.*xbm_r + xmu_r
      do n = 1, 4
         xcrg(n) = WGAMMA(xcre(n))
      end do
      xorg2 = 1./xcrg(2)

      xcse(1) = 1.+xbm_s
      xcse(2) = 1.+xmu_s
      xcse(3) = 1.+xbm_s + xmu_s
      xcse(4) = 1.+2.*xbm_s + xmu_s
      do n = 1, 4
         xcsg(n) = WGAMMA(xcse(n))
      end do
      xosg2 = 1./xcsg(2)

      xcge(1) = 1.+xbm_g
      xcge(2) = 1.+xmu_g
      xcge(3) = 1.+xbm_g + xmu_g
      xcge(4) = 1.+2.*xbm_g + xmu_g
      do n = 1, 4
         xcgg(n) = WGAMMA(xcge(n))
      end do
      xogg2 = 1./xcgg(2)

      xobmr = 1./xbm_r
      xoams = 1./xam_s
      xobms = 1./xbm_s
      xocms = xoams**xobms
      xoamg = 1./xam_g
      xobmg = 1./xbm_g
      xocmg = xoamg**xobmg

   end subroutine radar_init

!+---+-----------------------------------------------------------------+
!+---+-----------------------------------------------------------------+

   complex*16 function m_complex_water_ray(lambda, T)

!      Complex refractive Index of Water as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.001,1.0] m; T in [-10.0,30.0] deg C
!      after Ray (1972)

      implicit none
      double precision, intent(IN):: T, lambda
      double precision:: epsinf, epss, epsr, epsi
      double precision:: alpha, lambdas, sigma, nenner
      complex*16, parameter:: i = (0d0, 1d0)
      double precision, parameter:: PIx = 3.1415926535897932384626434d0

      epsinf = 5.27137d0 + 0.02164740d0*T - 0.00131198d0*T*T
      epss = 78.54d+0*(1.0 - 4.579d-3*(T - 25.0) &
                       + 1.190d-5*(T - 25.0)*(T - 25.0) &
                       - 2.800d-8*(T - 25.0)*(T - 25.0)*(T - 25.0))
      alpha = -16.8129d0/(T + 273.16) + 0.0609265d0
      lambdas = 0.00033836d0*exp(2513.98d0/(T + 273.16))*1e-2

      nenner = 1.d0 + 2.d0*(lambdas/lambda)**(1d0 - alpha)*sin(alpha*PIx*0.5) &
               + (lambdas/lambda)**(2d0 - 2d0*alpha)
      epsr = epsinf + ((epss - epsinf)*((lambdas/lambda)**(1d0 - alpha) &
                                        *sin(alpha*PIx*0.5) + 1d0))/nenner
      epsi = ((epss - epsinf)*((lambdas/lambda)**(1d0 - alpha) &
                               *cos(alpha*PIx*0.5) + 0d0))/nenner &
             + lambda*1.25664/1.88496

      m_complex_water_ray = sqrt(cmplx(epsr, -epsi))

   end function m_complex_water_ray

!+---+-----------------------------------------------------------------+

   complex*16 function m_complex_ice_maetzler(lambda, T)

!      complex refractive index of ice as function of Temperature T
!      [deg C] and radar wavelength lambda [m]; valid for
!      lambda in [0.0001,30] m; T in [-250.0,0.0] C
!      Original comment from the Matlab-routine of Prof. Maetzler:
!      Function for calculating the relative permittivity of pure ice in
!      the microwave region, according to C. Maetzler, "Microwave
!      properties of ice and snow", in B. Schmitt et al. (eds.) Solar
!      System Ices, Astrophys. and Space Sci. Library, Vol. 227, Kluwer
!      Academic Publishers, Dordrecht, pp. 241-257 (1998). Input:
!      TK = temperature (K), range 20 to 273.15
!      f = frequency in GHz, range 0.01 to 3000

      implicit none
      double precision, intent(IN):: T, lambda
      double precision:: f, c, TK, B1, B2, b, deltabeta, betam, beta, theta, alfa

      c = 2.99d8
      TK = T + 273.16
      f = c/lambda*1d-9

      B1 = 0.0207
      B2 = 1.16d-11
      b = 335.0d0
      deltabeta = exp(-10.02 + 0.0364*(TK - 273.16))
      betam = (B1/TK)*(exp(b/TK)/((exp(b/TK) - 1)**2)) + B2*f*f
      beta = betam + deltabeta
      theta = 300./TK - 1.
      alfa = (0.00504d0 + 0.0062d0*theta)*exp(-22.1d0*theta)
      m_complex_ice_maetzler = 3.1884 + 9.1e-4*(TK - 273.16)
      m_complex_ice_maetzler = m_complex_ice_maetzler &
                               + cmplx(0.0d0, (alfa/f + beta*f))
      m_complex_ice_maetzler = sqrt(conjg(m_complex_ice_maetzler))

   end function m_complex_ice_maetzler

!+---+-----------------------------------------------------------------+

   subroutine rayleigh_soak_wetgraupel(x_g, a_geo, b_geo, fmelt, &
                                       meltratio_outside, m_w, m_i, lambda, C_back, &
                                       mixingrule, matrix, inclusion, &
                                       host, hostmatrix, hostinclusion)

      implicit none

      double precision, intent(in):: x_g, a_geo, b_geo, fmelt, lambda, &
         meltratio_outside
      double precision, intent(out):: C_back
      complex*16, intent(in):: m_w, m_i
      character(len=*), intent(in):: mixingrule, matrix, inclusion, &
                                     host, hostmatrix, hostinclusion

      complex*16:: m_core, m_air
      double precision:: D_large, D_g, rhog, x_w, xw_a, fm, fmgrenz, &
         volg, vg, volair, volice, volwater, &
         meltratio_outside_grenz, mra
      integer:: error
      double precision, parameter:: PIx = 3.1415926535897932384626434d0

!     refractive index of air:
      m_air = (1.0d0, 0.0d0)

!     Limiting the degree of melting --- for safety:
      fm = DMAX1(DMIN1(fmelt, 1.0d0), 0.0d0)
!     Limiting the ratio of (melting on outside)/(melting on inside):
      mra = DMAX1(DMIN1(meltratio_outside, 1.0d0), 0.0d0)

!    ! The relative portion of meltwater melting at outside should increase
!    ! from the given input value (between 0 and 1)
!    ! to 1 as the degree of melting approaches 1,
!    ! so that the melting particle "converges" to a water drop.
!    ! Simplest assumption is linear:
      mra = mra + (1.0d0 - mra)*fm

      x_w = x_g*fm

      D_g = a_geo*x_g**b_geo

      if (D_g .ge. 1d-12) then

         vg = PIx/6.*D_g**3
         rhog = DMAX1(DMIN1(x_g/vg, 900.0d0), 10.0d0)
         vg = x_g/rhog

         meltratio_outside_grenz = 1.0d0 - rhog/1000.

         if (mra .le. meltratio_outside_grenz) then
            !..In this case, it cannot happen that, during melting, all the
            !.. air inclusions within the ice particle get filled with
            !.. meltwater. This only happens at the end of all melting.
            volg = vg*(1.0d0 - mra*fm)

         else
            !..In this case, at some melting degree fm, all the air
            !.. inclusions get filled with meltwater.
            fmgrenz = (900.0 - rhog)/(mra*900.0 - rhog + 900.0*rhog/1000.)

            if (fm .le. fmgrenz) then
               !.. not all air pockets are filled:
               volg = (1.0 - mra*fm)*vg
            else
               !..all air pockets are filled with meltwater, now the
               !.. entire ice sceleton melts homogeneously:
               volg = (x_g - x_w)/900.0 + x_w/1000.
            end if

         end if

         D_large = (6.0/PIx*volg)**(1./3.)
         volice = (x_g - x_w)/(volg*900.0)
         volwater = x_w/(1000.*volg)
         volair = 1.0 - volice - volwater

         !..complex index of refraction for the ice-air-water mixture
         !.. of the particle:
         m_core = get_m_mix_nested(m_air, m_i, m_w, volair, volice, &
                                   volwater, mixingrule, host, matrix, inclusion, &
                                   hostmatrix, hostinclusion, error)
         if (error .ne. 0) then
            C_back = 0.0d0
            return
         end if

         !..Rayleigh-backscattering coefficient of melting particle:
         C_back = (abs((m_core**2 - 1.0d0)/(m_core**2 + 2.0d0)))**2 &
                  *PI5*D_large**6/lamda4

      else
         C_back = 0.0d0
      end if

   end subroutine rayleigh_soak_wetgraupel

!+---+-----------------------------------------------------------------+

   complex*16 function get_m_mix_nested(m_a, m_i, m_w, volair, &
                                        volice, volwater, mixingrule, host, matrix, &
                                        inclusion, hostmatrix, hostinclusion, cumulerror)

      implicit none

      double precision, intent(in):: volice, volair, volwater
      complex*16, intent(in):: m_a, m_i, m_w
      character(len=*), intent(in):: mixingrule, host, matrix, &
                                     inclusion, hostmatrix, hostinclusion
      integer, intent(out):: cumulerror

      double precision:: vol1, vol2
      complex*16:: mtmp
      integer:: error

      !..Folded: ( (m1 + m2) + m3), where m1,m2,m3 could each be
      !.. air, ice, or water

      cumulerror = 0
      get_m_mix_nested = cmplx(1.0d0, 0.0d0)

      if (host .eq. 'air') then

         if (matrix .eq. 'air') then
            write (radar_debug, *) 'GET_M_MIX_NESTED: bad matrix: ', matrix
            call wrf_debug(150, radar_debug)
            cumulerror = cumulerror + 1
         else
            vol1 = volice/max(volice + volwater, 1d-10)
            vol2 = 1.0d0 - vol1
            mtmp = get_m_mix(m_a, m_i, m_w, 0.0d0, vol1, vol2, &
                             mixingrule, matrix, inclusion, error)
            cumulerror = cumulerror + error

            if (hostmatrix .eq. 'air') then
               get_m_mix_nested = get_m_mix(m_a, mtmp, 2.0*m_a, &
                                            volair, (1.0d0 - volair), 0.0d0, mixingrule, &
                                            hostmatrix, hostinclusion, error)
               cumulerror = cumulerror + error
            elseif (hostmatrix .eq. 'icewater') then
               get_m_mix_nested = get_m_mix(m_a, mtmp, 2.0*m_a, &
                                            volair, (1.0d0 - volair), 0.0d0, mixingrule, &
                                            'ice', hostinclusion, error)
               cumulerror = cumulerror + error
            else
               write (radar_debug, *) 'GET_M_MIX_NESTED: bad hostmatrix: ', &
                  hostmatrix
               call wrf_debug(150, radar_debug)
               cumulerror = cumulerror + 1
            end if
         end if

      elseif (host .eq. 'ice') then

         if (matrix .eq. 'ice') then
            write (radar_debug, *) 'GET_M_MIX_NESTED: bad matrix: ', matrix
            call wrf_debug(150, radar_debug)
            cumulerror = cumulerror + 1
         else
            vol1 = volair/max(volair + volwater, 1d-10)
            vol2 = 1.0d0 - vol1
            mtmp = get_m_mix(m_a, m_i, m_w, vol1, 0.0d0, vol2, &
                             mixingrule, matrix, inclusion, error)
            cumulerror = cumulerror + error

            if (hostmatrix .eq. 'ice') then
               get_m_mix_nested = get_m_mix(mtmp, m_i, 2.0*m_a, &
                                            (1.0d0 - volice), volice, 0.0d0, mixingrule, &
                                            hostmatrix, hostinclusion, error)
               cumulerror = cumulerror + error
            elseif (hostmatrix .eq. 'airwater') then
               get_m_mix_nested = get_m_mix(mtmp, m_i, 2.0*m_a, &
                                            (1.0d0 - volice), volice, 0.0d0, mixingrule, &
                                            'air', hostinclusion, error)
               cumulerror = cumulerror + error
            else
               write (radar_debug, *) 'GET_M_MIX_NESTED: bad hostmatrix: ', &
                  hostmatrix
               call wrf_debug(150, radar_debug)
               cumulerror = cumulerror + 1
            end if
         end if

      elseif (host .eq. 'water') then

         if (matrix .eq. 'water') then
            write (radar_debug, *) 'GET_M_MIX_NESTED: bad matrix: ', matrix
            call wrf_debug(150, radar_debug)
            cumulerror = cumulerror + 1
         else
            vol1 = volair/max(volice + volair, 1d-10)
            vol2 = 1.0d0 - vol1
            mtmp = get_m_mix(m_a, m_i, m_w, vol1, vol2, 0.0d0, &
                             mixingrule, matrix, inclusion, error)
            cumulerror = cumulerror + error

            if (hostmatrix .eq. 'water') then
               get_m_mix_nested = get_m_mix(2*m_a, mtmp, m_w, &
                                            0.0d0, (1.0d0 - volwater), volwater, mixingrule, &
                                            hostmatrix, hostinclusion, error)
               cumulerror = cumulerror + error
            elseif (hostmatrix .eq. 'airice') then
               get_m_mix_nested = get_m_mix(2*m_a, mtmp, m_w, &
                                            0.0d0, (1.0d0 - volwater), volwater, mixingrule, &
                                            'ice', hostinclusion, error)
               cumulerror = cumulerror + error
            else
               write (radar_debug, *) 'GET_M_MIX_NESTED: bad hostmatrix: ', &
                  hostmatrix
               call wrf_debug(150, radar_debug)
               cumulerror = cumulerror + 1
            end if
         end if

      elseif (host .eq. 'none') then

         get_m_mix_nested = get_m_mix(m_a, m_i, m_w, &
                                      volair, volice, volwater, mixingrule, &
                                      matrix, inclusion, error)
         cumulerror = cumulerror + error

      else
         write (radar_debug, *) 'GET_M_MIX_NESTED: unknown matrix: ', host
         call wrf_debug(150, radar_debug)
         cumulerror = cumulerror + 1
      end if

      if (cumulerror .ne. 0) then
         write (radar_debug, *) 'GET_M_MIX_NESTED: error encountered'
         call wrf_debug(150, radar_debug)
         get_m_mix_nested = cmplx(1.0d0, 0.0d0)
      end if

   end function get_m_mix_nested

!+---+-----------------------------------------------------------------+

   complex*16 function get_m_mix(m_a, m_i, m_w, volair, volice, &
                                 volwater, mixingrule, matrix, inclusion, error)

      implicit none

      double precision, intent(in):: volice, volair, volwater
      complex*16, intent(in):: m_a, m_i, m_w
      character(len=*), intent(in):: mixingrule, matrix, inclusion
      integer, intent(out):: error

      error = 0
      get_m_mix = cmplx(1.0d0, 0.0d0)

      if (mixingrule .eq. 'maxwellgarnett') then
         if (matrix .eq. 'ice') then
            get_m_mix = m_complex_maxwellgarnett(volice, volair, volwater, &
                                                 m_i, m_a, m_w, inclusion, error)
         elseif (matrix .eq. 'water') then
            get_m_mix = m_complex_maxwellgarnett(volwater, volair, volice, &
                                                 m_w, m_a, m_i, inclusion, error)
         elseif (matrix .eq. 'air') then
            get_m_mix = m_complex_maxwellgarnett(volair, volwater, volice, &
                                                 m_a, m_w, m_i, inclusion, error)
         else
            write (radar_debug, *) 'GET_M_MIX: unknown matrix: ', matrix
            call wrf_debug(150, radar_debug)
            error = 1
         end if

      else
         write (radar_debug, *) 'GET_M_MIX: unknown mixingrule: ', mixingrule
         call wrf_debug(150, radar_debug)
         error = 2
      end if

      if (error .ne. 0) then
         write (radar_debug, *) 'GET_M_MIX: error encountered'
         call wrf_debug(150, radar_debug)
      end if

   end function get_m_mix

!+---+-----------------------------------------------------------------+

   complex*16 function m_complex_maxwellgarnett(vol1, vol2, vol3, &
                                                m1, m2, m3, inclusion, error)

      implicit none

      complex*16 :: m1, m2, m3
      double precision :: vol1, vol2, vol3
      character(len=*) :: inclusion

      complex*16 :: beta2, beta3, m1t, m2t, m3t
      integer, intent(out) :: error

      error = 0

      if (DABS(vol1 + vol2 + vol3 - 1.0d0) .gt. 1d-6) then
         write (radar_debug, *) 'M_COMPLEX_MAXWELLGARNETT: sum of the ', &
            'partial volume fractions is not 1...ERROR'
         call wrf_debug(150, radar_debug)
         m_complex_maxwellgarnett = cmplx(-999.99d0, -999.99d0)
         error = 1
         return
      end if

      m1t = m1**2
      m2t = m2**2
      m3t = m3**2

      if (inclusion .eq. 'spherical') then
         beta2 = 3.0d0*m1t/(m2t + 2.0d0*m1t)
         beta3 = 3.0d0*m1t/(m3t + 2.0d0*m1t)
      elseif (inclusion .eq. 'spheroidal') then
         beta2 = 2.0d0*m1t/(m2t - m1t)*(m2t/(m2t - m1t)*log(m2t/m1t) - 1.0d0)
         beta3 = 2.0d0*m1t/(m3t - m1t)*(m3t/(m3t - m1t)*log(m3t/m1t) - 1.0d0)
      else
         write (radar_debug, *) 'M_COMPLEX_MAXWELLGARNETT: ', &
            'unknown inclusion: ', inclusion
         call wrf_debug(150, radar_debug)
         m_complex_maxwellgarnett = DCMPLX(-999.99d0, -999.99d0)
         error = 1
         return
      end if

      m_complex_maxwellgarnett = &
         sqrt(((1.0d0 - vol2 - vol3)*m1t + vol2*beta2*m2t + vol3*beta3*m3t)/ &
              (1.0d0 - vol2 - vol3 + vol2*beta2 + vol3*beta3))

   end function m_complex_maxwellgarnett

!+---+-----------------------------------------------------------------+
   real function GAMMLN(XX)
!     --- RETURNS THE VALUE LN(GAMMA(XX)) FOR XX > 0.
      implicit none
      real, intent(IN):: XX
      double precision, parameter:: STP = 2.5066282746310005d0
      double precision, dimension(6), parameter:: &
         COF = (/76.18009172947146d0, -86.50532032941677d0, &
                 24.01409824083091d0, -1.231739572450155d0, &
                 .1208650973866179d-2, -.5395239384953d-5/)
      double precision:: SER, TMP, X, Y
      integer:: J

      X = XX
      Y = X
      TMP = X + 5.5d0
      TMP = (X + 0.5d0)*log(TMP) - TMP
      SER = 1.000000000190015d0
      do 11 J = 1, 6
         Y = Y + 1.d0
         SER = SER + COF(J)/Y
11       continue
         GAMMLN = TMP + log(STP*SER/X)
         end function GAMMLN
!  (C) Copr. 1986-92 Numerical Recipes Software 2.02
!+---+-----------------------------------------------------------------+
         real function WGAMMA(y)

            implicit none
            real, intent(IN):: y

            WGAMMA = exp(GAMMLN(y))

         end function WGAMMA

!+---+-----------------------------------------------------------------+
         end module module_mp_radar
!+---+-----------------------------------------------------------------+
